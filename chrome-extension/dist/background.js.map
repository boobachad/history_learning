{"version":3,"file":"background.js","mappings":";;;;;AAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,oBAAoB;AACvF;AACA;AACA;AACA,uDAAuD,wBAAwB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,gBAAgB;AAC/D;AACA,wBAAwB,oBAAoB;AAC5C;AACA,6DAA6D,MAAM,GAAG,eAAe;AACrF;AACA;AACA;AACA,oDAAoD,OAAO;AAC3D,2DAA2D,MAAM,IAAI,yDAAyD;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,YAAY,GAAG,cAAc,OAAO,gBAAgB;AACzG;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,0CAA0C,aAAa;AACvD;AACA;AACA;AACA,SAAS;AACT,0CAA0C,aAAa;AACvD;AACA;AACA,4CAA4C,aAAa;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA,+BAA+B,wBAAwB;AACvD,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,2BAA2B,eAAe;AAC1C,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,2BAA2B,sCAAsC;AACjE,SAAS;AACT,qBAAqB;AACrB;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,gBAAgB,qBAAqB;AACrC;AACA,2BAA2B,oDAAoD;AAC/E;AACA;AACA;AACA,2BAA2B,6EAA6E;AACxG;AACA;AACA,+BAA+B,qBAAqB;AACpD,2BAA2B,eAAe;AAC1C,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,2BAA2B,sCAAsC;AACjE,SAAS;AACT,qBAAqB;AACrB;AACA,CAAC","sources":["webpack://chrome-extension/./src/background.ts"],"sourcesContent":["\"use strict\";\n/// <reference types=\"chrome\"/>\n// Constants\nconst BATCH_SIZE = 50;\nconst API_ENDPOINT = \"http://localhost:3000/api/entries/submit\";\n// Current sync status\nlet currentStatus = {\n    status: 'idle',\n    currentBatch: 0,\n    totalBatches: 0,\n    processedEntries: 0,\n    error: undefined\n};\n// Check if Chrome API is available\nfunction isChromeAPIAvailable() {\n    return typeof chrome !== 'undefined' &&\n        typeof chrome.runtime !== 'undefined' &&\n        typeof chrome.history !== 'undefined';\n}\n// Update and broadcast sync status\nfunction updateSyncStatus(status) {\n    console.log('[Background] Updating status:', status);\n    currentStatus = { ...currentStatus, ...status };\n    // Broadcast to all extension views (popup, etc)\n    chrome.runtime.sendMessage({\n        type: 'SYNC_STATUS',\n        status: currentStatus\n    }).catch((error) => {\n        console.error('[Background] Failed to broadcast status:', error);\n    });\n}\n// Helper function to chunk array into batches\nfunction chunkArray(array, size) {\n    const chunks = [];\n    for (let i = 0; i < array.length; i += size) {\n        chunks.push(array.slice(i, i + size));\n    }\n    return chunks;\n}\n// Process history entries in batches\nasync function processHistoryInBatches(startTime, endTime) {\n    try {\n        console.log('[Background] Starting history processing:', { startTime, endTime });\n        // Convert times to milliseconds\n        const startTimeMs = new Date(startTime).getTime();\n        const endTimeMs = new Date(endTime).getTime();\n        console.log('[Background] Converted times:', { startTimeMs, endTimeMs });\n        // Fetch history entries\n        const historyEntries = await new Promise((resolve, reject) => {\n            if (!chrome.history?.search) {\n                console.error('[Background] Chrome history API not available');\n                reject(new Error(\"Chrome history API is not available\"));\n                return;\n            }\n            console.log('[Background] Searching history...');\n            chrome.history.search({\n                text: \"\",\n                startTime: startTimeMs,\n                endTime: endTimeMs,\n                maxResults: 10000\n            }, (entries) => {\n                if (chrome.runtime.lastError) {\n                    console.error('[Background] History search error:', chrome.runtime.lastError);\n                    reject(chrome.runtime.lastError);\n                    return;\n                }\n                console.log('[Background] Found entries:', entries.length);\n                // Filter out entries with missing required fields\n                const validEntries = entries.filter(entry => entry.url &&\n                    entry.title &&\n                    entry.lastVisitTime);\n                console.log('[Background] Valid entries:', validEntries.length);\n                resolve(validEntries);\n            });\n        });\n        if (!historyEntries.length) {\n            console.log('[Background] No history entries found');\n            return;\n        }\n        // Process entries in batches\n        const batches = chunkArray(historyEntries, BATCH_SIZE);\n        console.log(`[Background] Processing ${batches.length} batches`);\n        // Process each batch\n        for (let i = 0; i < batches.length; i++) {\n            try {\n                console.log(`[Background] Processing batch ${i + 1}/${batches.length}`);\n                await processHistoryBatch(batches[i], startTime, endTime, i + 1, batches.length);\n            }\n            catch (error) {\n                console.error(`[Background] Batch ${i + 1} failed:`, error);\n                throw new Error(`Failed to process batch ${i + 1}: ${error instanceof Error ? error.message : 'Unknown error'}`);\n            }\n        }\n        console.log('[Background] All batches processed successfully');\n    }\n    catch (error) {\n        console.error('[Background] Processing failed:', error);\n        throw error;\n    }\n}\n// Process a single batch of history entries\nasync function processHistoryBatch(entries, startTime, endTime, batchNumber, totalBatches) {\n    try {\n        console.log(`[Background] Processing batch ${batchNumber}/${totalBatches} with ${entries.length} entries`);\n        // Update status\n        updateSyncStatus({\n            status: 'processing',\n            currentBatch: batchNumber,\n            totalBatches,\n            processedEntries: entries.length\n        });\n        // Send batch to API\n        const response = await fetch(API_ENDPOINT, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify({\n                startTime,\n                stopTime: endTime,\n                history: entries.map(entry => ({\n                    url: entry.url,\n                    title: entry.title,\n                    timestamp: new Date(entry.lastVisitTime).toISOString(),\n                    visitTime: 0, // We don't have this info from history API\n                    videoLength: 0, // We don't have this info from history API\n                    watchedLength: 0, // We don't have this info from history API\n                }))\n            })\n        });\n        if (!response.ok) {\n            const error = await response.json();\n            throw new Error(error.details || 'Failed to process batch');\n        }\n        const result = await response.json();\n        console.log(`[Background] Batch ${batchNumber} processed:`, result);\n        // Update status with processed entries\n        updateSyncStatus({\n            processedEntries: (currentStatus.processedEntries || 0) + entries.length\n        });\n        console.log(`[Background] Batch ${batchNumber} completed successfully`);\n    }\n    catch (error) {\n        console.error(`[Background] Batch ${batchNumber} failed:`, error);\n        throw error;\n    }\n}\n// Main message handler\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n    console.log('[Background] Received message:', message);\n    // Handle status requests\n    if (message.type === 'GET_STATUS') {\n        console.log('[Background] Sending current status:', currentStatus);\n        sendResponse({ status: currentStatus });\n        return true;\n    }\n    // Handle history processing requests\n    if (message.type === 'PROCESS_HISTORY') {\n        const { startTime, endTime } = message;\n        if (!startTime || !endTime) {\n            const error = 'Missing start or end time';\n            console.error('[Background]', error);\n            updateSyncStatus({ status: 'error', error });\n            sendResponse({ success: false, error });\n            return true;\n        }\n        // Start processing\n        updateSyncStatus({\n            status: 'processing',\n            currentBatch: 0,\n            totalBatches: 0,\n            processedEntries: 0,\n            error: undefined\n        });\n        processHistoryInBatches(startTime, endTime)\n            .then(() => {\n            console.log('[Background] Processing completed successfully');\n            updateSyncStatus({\n                status: 'completed',\n                error: undefined\n            });\n            sendResponse({ success: true });\n        })\n            .catch((error) => {\n            console.error('[Background] Processing error:', error);\n            updateSyncStatus({\n                status: 'error',\n                error: error instanceof Error ? error.message : 'Unknown error'\n            });\n            sendResponse({ success: false, error: error.message });\n        });\n        return true; // Keep the message channel open for async response\n    }\n});\n// Listen for external connections\nchrome.runtime.onMessageExternal.addListener((message, sender, sendResponse) => {\n    console.log('[Background] Received external message:', message, 'from:', sender);\n    // Handle history processing requests\n    if (message.type === 'PROCESS_HISTORY') {\n        const { startTime, endTime } = message;\n        if (!startTime || !endTime) {\n            sendResponse({ success: false, error: 'Missing start or end time' });\n            return true;\n        }\n        // Start processing\n        updateSyncStatus({ status: 'processing', currentBatch: 0, totalBatches: 0, processedEntries: 0 });\n        processHistoryInBatches(startTime, endTime)\n            .then(() => {\n            updateSyncStatus({ status: 'completed' });\n            sendResponse({ success: true });\n        })\n            .catch((error) => {\n            console.error('[Background] Processing error:', error);\n            updateSyncStatus({\n                status: 'error',\n                error: error instanceof Error ? error.message : 'Unknown error'\n            });\n            sendResponse({ success: false, error: error.message });\n        });\n        return true; // Keep the message channel open for async response\n    }\n});\n"],"names":[],"sourceRoot":""}